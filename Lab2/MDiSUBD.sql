-- LAB 2 --
DROP TABLE STUDENTS;
DROP TABLE GROUPS;
DROP TABLE LOG_STUDENTS;
DROP SEQUENCE SEQ_GROUPS_ID;
DROP SEQUENCE SEQ_STUDENTS_ID;

-- TASK 1 --
CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    GROUP_ID NUMBER NOT NULL
);
/

CREATE TABLE GROUPS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    C_VAL NUMBER DEFAULT 0
);
/
-- TASK 2 --
-- AUTOINCEMENT
CREATE SEQUENCE SEQ_GROUPS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;
/

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_GROUPS
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    SELECT SEQ_GROUPS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/

CREATE SEQUENCE SEQ_STUDENTS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;
/

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_STUDENTS
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    SELECT SEQ_STUDENTS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/

-- UNIQUE
CREATE OR REPLACE TRIGGER TRG_A_CHECK_UNIQUE_GROUP_ID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_ID_GROUP NUMBER;
BEGIN  
    IF :OLD.ID IS NULL OR :OLD.ID != :NEW.ID THEN
        SELECT COUNT(*) INTO COUNT_ID_GROUP FROM GROUPS WHERE ID = :NEW.ID;
        
        IF COUNT_ID_GROUP != 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
        END IF;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER CHECK_UNIQUE_STUDENT_ID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    COUNT_ID_STUDENT NUMBER;
BEGIN
    IF :OLD.ID IS NULL OR :OLD.ID != :NEW.ID THEN
        SELECT COUNT(*) INTO COUNT_ID_STUDENT FROM STUDENTS WHERE ID = :NEW.ID;
    
        IF(COUNT_ID_STUDENT!=0) THEN
            RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
        END IF;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_B_CHECK_UNIQUE_GROUP_NAME
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_NAME_GROUP NUMBER;
BEGIN
    IF :OLD.NAME IS NULL OR :OLD.NAME != :NEW.NAME THEN
        SELECT COUNT(*) INTO COUNT_NAME_GROUP FROM GROUPS WHERE NAME = :NEW.NAME;
    
        IF COUNT_NAME_GROUP > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS NAME ALREADY EXISTS IN TABLE!');
        END IF;
    END IF;
END;
/

-- TASK 3 --
CREATE OR REPLACE TRIGGER CASCADE_DELETE_GROUP 
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;
/
-- TASK 4 --
CREATE TABLE LOG_STUDENTS (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USER_NAME VARCHAR(50),
    DATETIME TIMESTAMP,
    ACTION VARCHAR(10),
    STUDENT_ID NUMBER,
    STUDENT_NAME VARCHAR(60),
    GROUP_ID NUMBER
);
/

CREATE OR REPLACE TRIGGER LOG_STUDENTS_TR
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
CASE
    WHEN INSERTING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    WHEN UPDATING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'UPDATE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    WHEN DELETING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
END CASE;
END;
/
-- TASK 5 --
CREATE OR REPLACE PROCEDURE RESTORE_INFO (
    EN_DATETIME IN TIMESTAMP,
    TIMEOFFSET IN NUMBER
) IS 
    LIMIT_ TIMESTAMP;
BEGIN
    IF TIMEOFFSET IS NULL THEN
        LIMIT_ := EN_DATETIME;
    ELSE
        LIMIT_ := SYSTIMESTAMP - TIMEOFFSET;
    END IF;

    
    FOR INFO IN (SELECT STUDENT_ID, STUDENT_NAME, GROUP_ID, ACTION FROM LOG_STUDENTS WHERE EN_DATETIME <= LIMIT_) LOOP
        IF INFO.ACTION = 'INSERT' THEN
            DELETE FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
            INSERT INTO STUDENTS (ID, NAME, GROUP_ID) VALUES (INFO.STUDENT_ID, INFO.STUDENT_NAME, INFO.GROUP_ID);
        ELSIF INFO.ACTION = 'UPDATE' THEN
            UPDATE STUDENTS SET NAME = INFO.STUDENT_NAME, GROUP_ID = INFO.GROUP_ID WHERE ID = INFO.STUDENT_ID;
        ELSIF INFO.ACTION = 'DELETE' THEN
            DELETE FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
        END IF;
    END LOOP; 
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'ERROR! NO DATA FOUND!');
END;
/
-- TASK 6 --
CREATE OR REPLACE TRIGGER UPDATE_C_VAL
AFTER INSERT OR UPDATE OR DELETE
    ON STUDENTS
    FOR EACH ROW
BEGIN
    IF :OLD.GROUP_ID IS NULL OR :OLD.GROUP_ID != :NEW.GROUP_ID THEN 
    IF INSERTING THEN
        UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE id = :new.group_id;
    END IF;
    IF UPDATING THEN
        UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE id = :old.group_id;
        UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE id = :new.group_id;
    END IF;
    IF DELETING THEN
        UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE id = :old.group_id;
    END IF;
    END IF;
END;
/

SELECT * FROM GROUPS; 
/
SELECT * FROM STUDENTS;  
/
SELECT * FROM LOG_STUDENTS;
/

-- ÏÐÎÂÅÐÊÀ ÍÀ ÓÍÈÊÀËÜÍÎÑÒÜ ÍÀÇÂÀÍÈß È ID
INSERT INTO GROUPS (NAME) VALUES ('153504');
INSERT INTO GROUPS (NAME) VALUES ('153502');
/
SELECT * FROM GROUPS; 
/
INSERT INTO GROUPS (NAME) VALUES ('153502');
/
INSERT INTO GROUPS (NAME) VALUES ('153504');

-- ÄËß ÊÀÑÊÀÄÍÎÃÎ ÓÄÀËÅÍÈß
DELETE FROM GROUPS WHERE ID = 2;
/
SELECT * FROM GROUPS;
/
SELECT * FROM STUDENTS;

-- ÄÎÁÀÂËÅÍÈÅ ÑÒÓÄÅÍÒÀ Â ÃÐÓÏÏÓ È ÏÐÎÂÅÐÊÀ ÍÀ ÓÍÈÊÀËÜÍÎÑÒÜ ID
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES
('ÑÒÓÄÅÍÒ1', 2);
/
INSERT INTO STUDENTS (ID ,NAME, GROUP_ID) VALUES
(1, 'ÑÒÓÄÅÍÒ1', 1);
/
SELECT * FROM STUDENTS;

-- ×ÈÑÒÎ ÓÄÀËÅÍÈÅ (ÏÐÎÂÅÐÊÀ ÍÀ ÈÇÌÅÍÅÍÈÅ C_VAL)
DELETE FROM STUDENTS WHERE ID = 2;

SELECT * FROM GROUPS;

-- ÈÇÌÅÍÅÍÈÅ ÈÌÅÍÈ ÑÒÓÄÅÍÒÀ
UPDATE STUDENTS
SET NAME = 'ÑÒÓÄÅÍÒÎ×ÊÀ'
WHERE ID = 5;
/
SELECT * FROM STUDENTS;

-- ÏÐÎÖÅÄÓÐÀ ÏÎ ÂÎÑÑÒÀÍÎÂËÅÍÈÅ LOG
EXECUTE RESTORE_INFO(TO_TIMESTAMP('2024-03-02', 'YYYY-MM-DD HH24:MI:SS'), 5000);
/
EXECUTE RESTORE_INFO(TO_TIMESTAMP('2024-03-02', 'YYYY-MM-DD HH24:MI:SS'), NULL);
/
SELECT * FROM STUDENTS;
/
SELECT * FROM LOG_STUDENTS;


