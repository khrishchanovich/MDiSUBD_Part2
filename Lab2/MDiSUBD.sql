-- LAB 2 --
DROP TABLE STUDENTS;
DROP TABLE GROUPS;
DROP TABLE LOG_STUDENTS;
-- TASK 1 --
CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    GROUP_ID NOT NULL,
    
    CONSTRAINT student_id PRIMARY KEY (ID),
    CONSTRAINT fk_group FOREIGN KEY (GROUP_ID) REFERENCES GROUPS(ID) 
);

CREATE TABLE GROUPS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    C_VAL NUMBER NOT NULL,
    
    CONSTRAINT group_pk PRIMARY KEY (ID)
);

-- TASK 2 --
-- AUTOINCEMENT
CREATE SEQUENCE SEQ_GROUPS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_GROUPS
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    SELECT SEQ_GROUPS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

CREATE SEQUENCE SEQ_STUDENTS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_STUDENTS
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    SELECT SEQ_STUDENTS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

-- UNIQUE
CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_ID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_ID_GROUP NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_ID_GROUP FROM GROUPS WHERE ID = :NEW.ID;
    
    IF(COUNT_ID_GROUP!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

CREATE OR REPLACE TRIGGER CHECK_UNIQUE_STUDENT_ID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    COUNT_ID_STUDENT NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_ID_STUDENT FROM STUDENTS WHERE ID = :NEW.ID;
    
    IF(COUNT_ID_STUDENT!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_NAME
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_NAME_GROUP NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_NAME_GROUP FROM GROUPS WHERE NAME = :NEW.NAME;
    
    IF(COUNT_NAME_GROUP!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

-- TASK 3 --
CREATE OR REPLACE TRIGGER CASCADE_DELETE_GROUP 
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;

-- TASK 4 --
DROP TABLE LOG_STUDENTS;
CREATE TABLE LOG_STUDENTS (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USER_NAME VARCHAR(50),
    DATETIME TIMESTAMP,
    ACTION VARCHAR(10),
    STUDENT_ID NUMBER,
    STUDENT_NAME VARCHAR(60),
    GROUP_ID NUMBER
);

CREATE OR REPLACE TRIGGER LOG_STUDENTS_TR
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
CASE
    WHEN INSERTING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    WHEN UPDATING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'UPDATE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    WHEN DELETING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
END CASE;
END;

-- TASK 5 --
CREATE OR REPLACE PROCEDURE RESTORE_STUDENTS_INFO (
    DATETIME   IN TIMESTAMP,
    TIMEOFFSET IN INTERVAL DAY TO SECOND
) IS
BEGIN
    IF DATETIME IS NOT NULL THEN --все записи на конкретную дату и время 
        FOR INFO IN (SELECT * FROM LOG_STUDENTS WHERE TRUNC(DATETIME, 'MI') = TRUNC(DATETIME, 'MI')) --TRUNC для обрезания миллисекунд и других меньших единиц времени
        LOOP
            DBMS_OUTPUT.PUT_LINE('USER: ' || INFO.USER_NAME);
            DBMS_OUTPUT.PUT_LINE('ACTION: ' || INFO.ACTION);
            DBMS_OUTPUT.PUT_LINE('DATETIME: ' || TO_CHAR(INFO.DATETIME, 'YYYY-MM-DD HH24:MI:SS'));
            DBMS_OUTPUT.PUT_LINE('STUDENT ID: ' || INFO.STUDENT_ID);
            DBMS_OUTPUT.PUT_LINE('NAME: ' || INFO.STUDENT_NAME);
            DBMS_OUTPUT.PUT_LINE('GROUP ID: ' || INFO.GROUP_ID);
            DBMS_OUTPUT.PUT_LINE('---------------------------');
        END LOOP;
    ELSIF TIMEOFFSET IS NOT NULL THEN --все записи в рамках этого смещения времени
        FOR INFO IN (SELECT * FROM LOG_STUDENTS WHERE DATETIME >= SYSTIMESTAMP - TIMEOFFSET)
        LOOP
            DBMS_OUTPUT.PUT_LINE('USER: ' || INFO.USER_NAME);
            DBMS_OUTPUT.PUT_LINE('ACTION: ' || INFO.ACTION);
            DBMS_OUTPUT.PUT_LINE('DATETIME: ' || TO_CHAR(INFO.DATETIME, 'YYYY-MM-DD HH24:MI:SS'));
            DBMS_OUTPUT.PUT_LINE('STUDENT ID: ' || INFO.STUDENT_ID);
            DBMS_OUTPUT.PUT_LINE('NAME: ' || INFO.STUDENT_NAME);
            DBMS_OUTPUT.PUT_LINE('GROUP ID: ' || INFO.GROUP_ID);
            DBMS_OUTPUT.PUT_LINE('---------------------------');
        END LOOP;
    END IF;
END;

SELECT * FROM GROUPS; 
SELECT * FROM STUDENTS;  
INSERT INTO GROUPS (NAME, C_VAL) VALUES ('153504', 40);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES
('СТУДЕНТ1', 1);
SELECT * FROM LOG_STUDENTS;

execute restore_students_info(NULL, INTERVAL '1' HOUR);
execute restore_students_info(TO_TIMESTAMP('2024-02-11 13:08:24', 'YYYY-MM-DD HH24:MI:SS'), NULL);

-- TASK 6 --
CREATE OR REPLACE TRIGGER UPDATE_C_VAL_INFO
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
CASE
    WHEN INSERTING THEN
        UPDATE GROUPS SET C_VAL = (SELECT COUNT(*) FROM STUDENTS
        WHERE GROUP_ID = :OLD.GROUP_ID);
    WHEN UPDATING THEN
        UPDATE GROUPS SET C_VAL = (SELECT COUNT(*) FROM STUDENTS
        WHERE GROUP_ID = :OLD.GROUP_ID);
    WHEN DELETING THEN
        UPDATE GROUPS SET C_VAL = (SELECT COUNT(*) FROM STUDENTS
        WHERE GROUP_ID = :OLD.GROUP_ID);
END CASE;
END;

