-- LAB 2 --
DROP TABLE STUDENTS;
DROP TABLE GROUPS;
-- TASK 1 --
CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    GROUP_ID NOT NULL,
    
    CONSTRAINT student_id PRIMARY KEY (ID),
    CONSTRAINT fk_group FOREIGN KEY (GROUP_ID) REFERENCES GROUPS(ID) 
);

CREATE TABLE GROUPS (
    ID NUMBER,
    NAME VARCHAR2(50) NOT NULL,
    C_VAL NUMBER NOT NULL,
    
    CONSTRAINT group_pk PRIMARY KEY (ID)
);

-- TASK 2 --
-- AUTOINCEMENT
CREATE SEQUENCE SEQ_GROUPS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_GROUPS
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    SELECT SEQ_GROUPS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

CREATE SEQUENCE SEQ_STUDENTS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE OR REPLACE TRIGGER AUTO_INCREMENT_STUDENTS
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    SELECT SEQ_STUDENTS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

-- UNIQUE
CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_ID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_ID_GROUP NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_ID_GROUP FROM GROUPS WHERE ID = :NEW.ID;
    
    IF(COUNT_ID_GROUP!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

CREATE OR REPLACE TRIGGER CHECK_UNIQUE_STUDENT_ID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    COUNT_ID_STUDENT NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_ID_STUDENT FROM STUDENTS WHERE ID = :NEW.ID;
    
    IF(COUNT_ID_STUDENT!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_NAME
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_NAME_GROUP NUMBER;
BEGIN  
    SELECT COUNT(*) INTO COUNT_NAME_GROUP FROM GROUPS WHERE NAME = :NEW.NAME;
    
    IF(COUNT_NAME_GROUP!=0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;

-- TASK 3 --
CREATE OR REPLACE TRIGGER CASCADE_DELETE_GROUP 
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;

-- TASK 4 --
DROP TABLE LOG_STUDENTS;
CREATE TABLE LOG_STUDENTS (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USER_NAME VARCHAR(50),
    DATETIME TIMESTAMP,
    ACTION VARCHAR(10),
    STUDENT_ID NUMBER,
    STUDENT_NAME VARCHAR(60),
    GROUP_ID NUMBER
);

CREATE OR REPLACE TRIGGER LOG_STUDENTS_TR
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
CASE
    WHEN INSERTING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    WHEN UPDATING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'UPDATE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    WHEN DELETING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
END CASE;
END;

-- TASK 5 --
CREATE OR REPLACE PROCEDURE RESTORE_STUDENT_INFORMATION (
    DATETIME IN TIMESTAMP,
    TIMEOFFSET IN NUMBER DEFAULT 0
) AS
BEGIN
    IF TIMEOFFSET < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! OFFSET MUST BE NON-NEGATIVE!');
    END IF;
    
    IF TIMEOFFSET = 0 THEN
        SELECT * INTO :NEW.ID, :NEW.NAME
END;
    
INSERT INTO GROUPS (NAME, C_VAL) VALUES ('153503', 32);
SELECT * FROM GROUPS;
